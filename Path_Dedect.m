function [R1,C1] = Path_Dedect(P,N)

% 创建路径存储矩阵，存储所有的路径
R1 = zeros(10*N,N);
% 创建单点闭集，存储吸收态
C1 = zeros(N,1);

%遍历马尔可夫矩阵，将每个状态和其下一个可能到达的状态进行存储
f1 = 0;
f2 = 1;
f3 = 1;
R = 1;
for i = 1:N   % 遍历行
    for j = 1:N  % 遍历列
        %判断是否是吸收态
        if P(i,j) == 1 && (i == j)
            C1(f2,1) = i;
            f2 = f2 + 1;
        end
        
        % 路径存储矩阵1中存储该状态到其他状态的情况
        % 转移关系大于0，起始节点，且排除下一状态仍然为当前状态的可能路径，减少复杂度
        if P(i,j) > 0 && f1 == 0 && (i ~= j)  %不等于
            R1(R,f3) = i;  % 存储当前节点
            f3 = f3 + 1;
            R1(R,f3) = j;  % 存储下一个状态
            f1 = 1;
        end 


        % 已经获得起始节点后，遍历状态矩阵，拿所有的元素去测试
        % 当前路径的终点l到下一状态k的转移关系大于0，且l！=k
        % 并且k不是已经在路径中走过了，则纳入当前路径
        % 注意，由于我们的行数是从上到下进行遍历的，会导致能够检测到20到40，
        % 但是检测不到40到20的路径。所以这里for q = 1:N进行重新遍历，防止遗漏
        if f1 == 1
            for q = 1:N
                for l = 1:N
                    for k = 1:N
                        if (P(l,k)) > 0 && (R1(R,f3) == l) && (l ~= k) && (R1(R,f3+1) == 0) && ~(ismember(k,R1(R,2:100)))
                            f3 = f3+1;
                            R1(R,f3) = k;
                        end
                    end
                end
            end
            f1 = 0;
            f3 = 1;
            R = R + 1;
        end
    end
end